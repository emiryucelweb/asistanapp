{"version":3,"file":"formatters-BPsSO8Sl.js","sources":["../../src/shared/utils/formatters.ts"],"sourcesContent":["/**\n * Number and date formatting utilities\n */\n\nimport { logger } from './logger';\n\n/**\n * Format number with thousand separators (Turkish locale)\n * @param value - Number to format\n * @param decimals - Number of decimal places (default: 0)\n * @returns Formatted string with thousand separators\n */\nexport const formatNumber = (value: number, decimals: number = 0): string => {\n  return value.toLocaleString('tr-TR', {\n    minimumFractionDigits: decimals,\n    maximumFractionDigits: decimals\n  });\n};\n\n/**\n * Format currency (Turkish Lira)\n * @param value - Number to format as currency\n * @param showSymbol - Whether to show currency symbol (default: true)\n * @returns Formatted currency string\n */\nexport const formatCurrency = (value: number, showSymbol: boolean = true): string => {\n  const formatted = value.toLocaleString('tr-TR', {\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  });\n  return showSymbol ? `₺${formatted}` : formatted;\n};\n\n/**\n * Format percentage\n * @param value - Number to format as percentage\n * @param decimals - Number of decimal places (default: 1)\n * @returns Formatted percentage string\n */\nexport const formatPercentage = (value: number, decimals: number = 1): string => {\n  return `${value.toLocaleString('tr-TR', {\n    minimumFractionDigits: decimals,\n    maximumFractionDigits: decimals\n  })}%`;\n};\n\n/**\n * Format large numbers with K, M, B suffixes\n * @param value - Number to format\n * @returns Formatted string with suffix\n */\nexport const formatCompactNumber = (value: number): string => {\n  if (value >= 1000000000) {\n    return `${(value / 1000000000).toFixed(1)}B`;\n  }\n  if (value >= 1000000) {\n    return `${(value / 1000000).toFixed(1)}M`;\n  }\n  if (value >= 1000) {\n    return `${(value / 1000).toFixed(1)}K`;\n  }\n  return value.toString();\n};\n\n/**\n * Format date to Turkish locale\n * @param date - Date to format\n * @param format - Format type: 'short' | 'long' | 'full'\n * @returns Formatted date string\n */\nexport const formatDate = (date: Date | string, format: 'short' | 'long' | 'full' = 'short'): string => {\n  const dateObj = typeof date === 'string' ? new Date(date) : date;\n  \n  switch (format) {\n    case 'short':\n      return dateObj.toLocaleDateString('tr-TR');\n    case 'long':\n      return dateObj.toLocaleDateString('tr-TR', {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n      });\n    case 'full':\n      return dateObj.toLocaleDateString('tr-TR', {\n        weekday: 'long',\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n      });\n    default:\n      return dateObj.toLocaleDateString('tr-TR');\n  }\n};\n\n/**\n * Format time to Turkish locale\n * @param date - Date to format\n * @returns Formatted time string\n */\nexport const formatTime = (date: Date | string): string => {\n  const dateObj = typeof date === 'string' ? new Date(date) : date;\n  return dateObj.toLocaleTimeString('tr-TR', {\n    hour: '2-digit',\n    minute: '2-digit'\n  });\n};\n\n/**\n * Format date and time to Turkish locale\n * @param date - Date to format\n * @returns Formatted date and time string\n */\nexport const formatDateTime = (date: Date | string): string => {\n  const dateObj = typeof date === 'string' ? new Date(date) : date;\n  return `${formatDate(dateObj)} ${formatTime(dateObj)}`;\n};\n\n/**\n * Get relative time (e.g., \"5 minutes ago\")\n * @param date - Date to compare\n * @returns Relative time string in Turkish\n */\nexport const getRelativeTime = (date: Date | string): string => {\n  const dateObj = typeof date === 'string' ? new Date(date) : date;\n  const now = new Date();\n  const diffInMs = now.getTime() - dateObj.getTime();\n  const diffInMinutes = Math.floor(diffInMs / (1000 * 60));\n  const diffInHours = Math.floor(diffInMs / (1000 * 60 * 60));\n  const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));\n\n  if (diffInMinutes < 1) return 'Az önce';\n  if (diffInMinutes < 60) return `${diffInMinutes} dakika önce`;\n  if (diffInHours < 24) return `${diffInHours} saat önce`;\n  if (diffInDays < 7) return `${diffInDays} gün önce`;\n  if (diffInDays < 30) return `${Math.floor(diffInDays / 7)} hafta önce`;\n  if (diffInDays < 365) return `${Math.floor(diffInDays / 30)} ay önce`;\n  return `${Math.floor(diffInDays / 365)} yıl önce`;\n};\n\n/**\n * Format duration from seconds to MM:SS or HH:MM:SS format\n * Enterprise-grade with validation and error handling\n * \n * @param seconds - Total duration in seconds\n * @param showHours - Whether to show hours even if less than 1 hour\n * @returns Formatted duration string\n * \n * @example\n * ```ts\n * formatDuration(125)         // \"02:05\"\n * formatDuration(3600)        // \"60:00\"\n * formatDuration(3665, true)  // \"01:01:05\"\n * ```\n */\nexport const formatDuration = (seconds: number, showHours: boolean = false): string => {\n  // Validate input\n  if (typeof seconds !== 'number' || isNaN(seconds) || seconds < 0) {\n    logger.warn('[Formatters] Invalid duration seconds', new Error(`Invalid seconds: ${seconds}`));\n    return showHours ? '00:00:00' : '00:00';\n  }\n\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n\n  // Format with leading zeros\n  const pad = (num: number) => num.toString().padStart(2, '0');\n\n  if (hours > 0 || showHours) {\n    return `${pad(hours)}:${pad(minutes)}:${pad(secs)}`;\n  }\n\n  return `${pad(minutes)}:${pad(secs)}`;\n};\n\n/**\n * Format file size in human-readable format\n * \n * @param bytes - File size in bytes\n * @param decimals - Number of decimal places (default: 2)\n * @returns Formatted size string\n * \n * @example\n * ```ts\n * formatFileSize(1024)        // \"1.00 KB\"\n * formatFileSize(1536)        // \"1.50 KB\"\n * formatFileSize(1048576)     // \"1.00 MB\"\n * ```\n */\nexport const formatFileSize = (bytes: number, decimals: number = 2): string => {\n  if (bytes === 0) return '0 Bytes';\n  if (bytes < 0) return 'Invalid';\n\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals))} ${sizes[i]}`;\n};\n\n"],"names":["formatNumber","value","decimals","formatCurrency","showSymbol","formatted","formatDate","date","format","dateObj","formatTime","formatDateTime"],"mappings":"4BAYO,MAAMA,EAAe,CAACC,EAAeC,EAAmB,IACtDD,EAAM,eAAe,QAAS,CACnC,sBAAuBC,EACvB,sBAAuBA,CAAA,CACxB,EASUC,EAAiB,CAACF,EAAeG,EAAsB,KAAiB,CACnF,MAAMC,EAAYJ,EAAM,eAAe,QAAS,CAC9C,sBAAuB,EACvB,sBAAuB,CAAA,CACxB,EACD,OAAOG,EAAa,IAAIC,CAAS,GAAKA,CACxC,EAuCaC,EAAa,CAACC,EAAqBC,EAAoC,UAAoB,CACtG,MAAMC,EAAU,OAAOF,GAAS,SAAW,IAAI,KAAKA,CAAI,EAAIA,EAE5D,OAAQC,EAAA,CACN,IAAK,QACH,OAAOC,EAAQ,mBAAmB,OAAO,EAC3C,IAAK,OACH,OAAOA,EAAQ,mBAAmB,QAAS,CACzC,KAAM,UACN,MAAO,OACP,IAAK,SAAA,CACN,EACH,IAAK,OACH,OAAOA,EAAQ,mBAAmB,QAAS,CACzC,QAAS,OACT,KAAM,UACN,MAAO,OACP,IAAK,SAAA,CACN,EACH,QACE,OAAOA,EAAQ,mBAAmB,OAAO,CAAA,CAE/C,EAOaC,EAAcH,IACT,OAAOA,GAAS,SAAW,IAAI,KAAKA,CAAI,EAAIA,GAC7C,mBAAmB,QAAS,CACzC,KAAM,UACN,OAAQ,SAAA,CACT,EAQUI,EAAkBJ,GAAgC,CAC7D,MAAME,EAAU,OAAOF,GAAS,SAAW,IAAI,KAAKA,CAAI,EAAIA,EAC5D,MAAO,GAAGD,EAAWG,CAAO,CAAC,IAAIC,EAAWD,CAAO,CAAC,EACtD"}